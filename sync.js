var _ = require('lodash');
var fs = require('fs');
var program = require('commander');
var assert = require('assert');
var dns = require('dns');
var net = require('net');
var path = require('path');
var bcoin = require('bcoin');

function addTimestamp(o) {
    if (o.__ts__) {
        return;
    }
    var slice = Array.prototype.slice;
    ['log', 'debug', 'info', 'warn', 'error'].forEach(function(f) {
        var _ = o[f];
        o[f] = function() {
            var args = slice.call(arguments);
            args[0] = new Date().toISOString() + ' ' + args[0];
            return _.apply(o, args);
        };
    });
    o.__ts__ = true;
}
;

addTimestamp(console);

program
    .version('0.0.1')
    .option('-db, --database [path]', 'Enable database')
    .option('-t, --testnet', 'Use testnet')
    .option('-o, --output [path]', 'Chain output')
    .option('-p --peer [address]', 'Dedicated peer')
    .option('-s --size [size]', 'Pool size (default: 128)')
    .parse(process.argv);

if (!program.output) {
    console.log('Output path required');
    process.exit(2);
}

if (program.testnet) {
    bcoin.protocol.network.set('testnet');
    console.log('Using testnet');
} else {
    console.log('Using mainnet');
}

var pool;
var size = 128;

if (_.isNumber(program.size)) {
    size = program.size;
}

var opts = {};

if (program.peer) {
    _.merge(opts, {
        size: size,
        ignoreAddr: true,
        seeds: [program.peer]
    });
}

if (program.db) {
    var levelup = require('levelup');
    var sqldown = require('sqldown');
    pool = bcoin.pool(_.merge(opts, {
        storage: levelup(program.db, {
            db: sqldown,
            valueEncoding: 'json'
        })
    }));
} else {
    pool = bcoin.pool(opts);
}

pool.on('block', function(block) {
    var hash = bcoin.utils.revHex(block.hash('hex'));
    console.log('Got: %s from %s chain len %d orp %d act %d queue %d',
        hash,
        new Date(block.ts * 1000).toString(),
        pool.chain.index.hashes.length,
        pool.chain.orphan.count,
        pool.request.active,
        pool.request.queue.length);
});

pool.on('peer', function(peer) {
    var ips = pool.peers.all.map(function(peer) {
        if (!peer.socket || !peer.socket.remoteAddress)
            return;
        return peer.socket.remoteAddress;
    }).filter(Boolean);
    console.log('Peer IPs: %s', ips);
})

pool.on('error', function(err) {
    console.log('Error: %s', err.message);
});

pool.on('debug', function() {
    console.log.apply(null, arguments);
});

pool.on('chain-progress', function(progress) {
    console.log('Progress: ' + progress);
});

pool.once('full', finish);
process.once('SIGINT', finish);

pool.on('headers', function(headers, peer) {
    for (var i = 0; i < headers.length; i++) {
        console.log('Received header hash: %s from %s', bcoin.utils.revHex(headers[i].hash), peer.socket.remoteAddress);
    }
});

exports = pool;

pool.startSync();

var once = false;
function finish() {
    if (once)
        return;
    once = true;

    console.log('Done...');
    var chain = '// Autogenerated\n' +
        'module.exports = ' +
        JSON.stringify(pool.chain.toJSON(), null, 2) + '\n';
    var file = program.output;

    require('fs').writeFileSync(file, chain);
    pool.destroy();
}
